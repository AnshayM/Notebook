## ACID

+ 原子性Atomicity

  事务是最小的执行单元，不能再被分割。作为一个整体，要么全部执行，要么全部不执行

+ 一致性Consistency

  执行事务的前后，数据是一致的。比如转账前后钱的总数不会发生任何变化

+ 隔离性Isolation

  一个事务在执行的过程中，其他事务是不会对其产生影响的。各事务执行独立

+ 持久性Durability

  事务只要被执行后，就会被持久化下来。即便故障也不会影响

## 事务状态

+ 活动的active

  事务对应的数据库操作正在执行中，事务就是活动的

+ 部分提交的partially committed

  事务的最后一个操作执行完成(commit)，但由于操作是在内存中进行，所造成的影响并没刷新到磁盘，事务此时处于部分提交状态

+ 失败的failed

  当事务在活动的活着部分提交的状态时，由于某些错误（异常、断电）或人为停止事务(rollback)执行导致事务无法继续进行，事务就是失败的

+ 中止的aborted

  事务执行一般变为失败的状态时，需要撤销对数据库的影响即回滚数据库，回滚完毕后，事务就是中止的

+ 提交的commited

  当事务处于部分提交的状态时，将数据都同步到磁盘上后，事务就处于提交的状态

  <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/1/169d7fd5bd4ce2f1~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image_1d7bvq3401fpe1eum1d7qkop1f479.png-69.6kB" style="zoom: 67%;" />

## 事务提交

#### 自动提交

`autocommit`变量为`on`即开启自动提交，一条语句对应一个事务

#### 显示提交

手动`begin`或者`start transaction`开启事务后，再手动`commit`

#### 隐式提交

开启事务后，一旦执行某些语句均会触发隐式提交。主要还是因为某些语句一旦执行后就无法回滚，或回滚会产生意想不到的结果所以需要隐式提交

+ 定义或修改数据库对象的数据定义语言(DDL)
+ 隐式使用或修改`mysql`库的表
  + SET PASSWORD、CREATE USER等等
+ 事务控制或关于锁定的语句
+ 加载数据的语句
  + LOAD DATA批量导数据
+ MySQL复制的一些语句
  + START SLAVE、STOP SLAVE、RESET SLAVE等等
+ 其他语句
  + OPTIMIZE TABLE、ANALYZE TABLE、FLUSH等等

## 保存点

事务执行过程中可使用保存点来打标记点

```sql
SAVEPOINT 保存点名称;
```

这样在进行回滚操作时可以指定回滚到某个保存点

```sql
ROLLBACK TO SAVEPOINT 保存点名称;
```

删除保存点

```sql
RELEASE SAVEPOINT 保存点名称;
```



## 实现原理

以InnoDB引擎为例

采取redo log重做日志来确保事务的**持久性**，事务操作记录都可以被持久化到该日志中

采取undo log回滚日志可以确保事务的**原子性**，事务在执行过程中也会生成一条反向的操作记录存储到日志中，一旦失败全部回滚

采取锁机制、MVCC可以确保事务的**隔离性**，事务在执行过程中其他事务不会影响该事务执行，做到了事务的独立隔离

## 隔离级别

+ 读未提交Read Uncommitted

  一个事务可以读取其他事务没有提交的数据。最低隔离级别，会发生脏读

+ 读已提交Read Committed

  一个事务可以读取到其他事务提交后的数据，不会读取到中间状态数据，虽然避免了脏读，但其他事务依然可以并发对操作的行记录进行修改，这就会导致前后两次读取到的行记录不一致，这就是发生了不可重复读；其他事务同样可以插入数据，这会导致前后连词读取到的行数量不一样，这就是发生了幻读

+ 可重复读Repeatable Read

  避免了事务进行中对同一行记录前后两次读取的行记录不一致问题，也就是可以避免不可重复读，当然脏读也是可以避免的。只是幻读还是会发生

+ 串行化Serializable

  顾名思义串行处理，同一时刻只能有一个事务执行，后续开启的事务只能排队，没有并发也就没有了并发安全问题，脏读、幻读、不可重复读统统可以避免。分布式事务中必须设置串行化隔离级别

任何隔离级别都不允许脏写!!!一个事务修改了另一个事务没有提交的修改过的数据。只要事务修改就对该行记录加锁，其他事务无法操作再次修改