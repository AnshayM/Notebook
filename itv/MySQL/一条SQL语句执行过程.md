## 查询语句

### 客户端

连接服务端`mysql -h$ip -u$user -p$pwd -P$port`

### Server层

#### 连接器

负责跟客户端建立连接、获取权限、维持和管理连接

#### 查询缓存

之前查询的语句和结果以key-value键值对缓存在内存中。如果要命中缓存需要查询语句一模一样，但这个模块在MySQL8.0就被移除了

#### 分析器

+ 词法分析：解析SQL关键词，比如select、表名T、列名等等

+ 语法分析：根据语法分析器的规则判定语法是否是标准SQL语法

#### 优化器

一个表有多个索引时，优化器需要判定选用哪个索引扫描的行数最少，这样执行的也更快，还会生成执行计划交由执行器执行

#### 执行器

分析器知道了做什么，优化器知道了怎么做。执行器就是直接执行，执行前需要做待操作的表进行权限校验，调用存储引擎层提供的API进行读写操作。在执行查询操作时，先根据查询条件调用引擎层API获取满足条件的第一行结果并放入结果集，之后循环调用取满足条件的下一行，如果想要将查询条件下推到存储引擎层进行筛选，这里就需要用到索引下推(Index Condition Pushdown)，这是MySQL5.6针对二级索引的优化，聚簇索引就不存在这种循环调用问题，因为索引及数据，直接由存储引擎层筛选扫描就直接全量返回给执行器

举例一个联合索引(name, age)，执行`select * from T where name like '章三' and age = 25;`

+ 关闭ICP：执行器调用引擎层进行索引值的筛选，还需要回表取聚簇索引的行记录，这样就会导致选取的二级索引有多少个`章三`就需要回表多少次，回表拿到所有行记录后需要返回给执行器进行`age`条件过滤
+ 开启ICP：引擎层根据`章三`索引到行后直接就在复合索引存储的`age`列进行条件过滤了，提前过滤`age=25`的列，可以减少了回表次数，也减少了执行器和引擎层交互的次数

## 更新语句

前边流程同查询语句类似，区别就是分析器需要分析出这是一条更新语句，server层多了写日志记录：binlog(归档日志)和redo log(重做日志)

#### WAL

Write-Ahead Logging预写日志，先写日志，再写磁盘。日志是放在内存中的，写入性能比磁盘快，在适当时机才会将内存数据刷到磁盘。这样可以提交读写性能，减少磁盘IO。日志是顺序IO，数据是随机IO。

#### 2PC

+ 执行器调用InnoDB引擎修改后，InnoDB引擎会先写redo log，只是这时redo log处于prepare状态
+ InnoDB引擎返回执行器修改成功后，执行器需要写binlog
+ 执行器写完binlog后，如果事务提交，那么InnoDB引擎会提交redo log，此时redo lod处于commit状态

2PC也是分布式系统中的事务常用解决方案

+ 第一阶段提交请求：先由协调节点向所有参与节点询问是否可以执行提交
+ 第二阶段提交执行：
  + 如果各参与节点响应同意消息，则由协调节点向所有参与节点发起正式提交，参与节点执行完毕后向协调节点发送完成消息，此时协调节点接收到所有参与节点完成消息后，正式完成事务
  + 如果各参与节点返回终止消息，获取第一阶段询问超时，协调节点就向所有参与节点发起回滚请求，所有参与节点回滚完毕后向协调节点发送回滚完成消息后，协调节点取消事务

<img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png" alt="img" style="zoom: 25%;" />