## 全局锁

+ 场景：全库逻辑备份
+ 命令：flush tables with read lock(FTWRL)
+ 作用：整个数据库实例加锁，DDL、DML及事务提交均会阻塞
+ 影响：主库执行业务更新停摆，从库执行不能执行从主库同步过来的binlog造成主从延迟

MySQL官方自带逻辑备份工具mysqldump，使用--single-transaction参数时，会在导数据前开启一个事务，来确保拿到一致性视图，正是因为InnoDB引擎事务的MVCC支持这个过程是可以正常进行数据更新的。但它只能作用于有事务支持的引擎库，所以这也就DBA一般建议开发人员选型InnoDB引擎原因之一

`set global readonly=true`也可以确保整个数据库只读，但因为该参数有可能**用来判断主从数据库**，并且使用FTWRL命令之后客户端发生异常断开后MySQL会自动释放这个全局锁，但设置readonly后，一旦客户端发生异常，就会导致数据库长期处于只读状态



## 表锁

+ 加锁：`lock table ... read/write`
+ 释放锁：`unlock tables`/客户端断开自动释放

### MDL

+ 加锁：对表做增删改查时加MDL读锁，对表做结构变更时加MDL写锁
+ 作用：保证读写正确性，确保操作表时该表结构不会有变更
+ 影响：读锁之间不互斥，读写锁之间、写锁之间互斥。一旦有会话开启事务后对表进行查询操作(加MDL读锁)，其他会话对表结构做变更(尝试获取MDL写锁阻塞)
+ 避免：从根本上避免长事务一直不提交。在`information_schema`库的`innodb_trx`表中可以查到正在执行的事务，可以暂停阻塞的DDL或者kill掉这个长事务。但kill掉有可能又有新的事务进来，所以最好时给DDL做超时设置，一旦超时就暂停不要阻塞后边业务。MariaDB合并AliSQL的这个功能`alter table ... NOWAIT[WAIT N] add column`

## 扩展

+ MySQL 5.6前DDL过程(alter table加减字段/索引)
  1. 按照旧表定义新建新表
  2. 给旧表加写锁
  3. 新表执行DDL操作
  4. 将旧表数据拷贝到新表
  5. 释放旧表写锁
  6. 删除旧表
  7. 新表重命名为旧表

​		缺点：视数据量大小占用存储空间、阻塞表的DDL和DML操作

+ MySQL Online DDL过程（MySQL实战45讲 06）
  1. 先获取MDL写锁（获取旧表定义。防止多个DDL同时操作同一张表，其他会话均阻塞）
  2. 降级成MDL读锁（准备阶段，确保其他会话可以获取旧表的MDL也就是可以执行读取操作，并且MDL读写锁是互斥的其他DDL也会阻塞）
  3. 执行DDL过程（上边的1-7步操作）
  4. 升级为MDL写锁（最终提交阶段，确保其他会话不会对表产生影响）
  5. 释放MDL写锁



## 行锁