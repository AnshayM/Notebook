#### 你了解哪些数据库引擎/Innodb和myIsam的区别

1. InnoDb主键索引是聚簇索引，MyIsam主键索引是非聚簇索引
2. Innodb支持行锁、表锁，MyIsam只支持表锁

#### mysql：事务的特性**ACID**

- Atomicity: 原子性，原子性表示要么全部成功，要么全部失败。通过undoLog来保证。undoLog记录数据修改前的信息。

- Consistency: 一致性，执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的

- Isolation：隔离性，并发访问数据库时，各个事务之间独立不受干扰

    四种隔离等级：读未提交、读已提交、可重复读、串行

- Durability：持久性，一旦提交了事务，其改变应该是永久性的(持久化在硬盘上)。持久性通过redoLog保证，内存写完后，会写一份redoLog，记录本次再某个页上做了什么修改。如果内存到落库的过程中mysql宕机了，可以通过redo log进行数据恢复。redo是顺序写的，写入速度也很快。(机制有点类似redis的aof)

所以，一致性是事务最终的目的，原子性、隔离性、持久性都是为了保证一致性的手段。



#### 不同隔离等级的问题

- 脏读：读取到其他事务未提交的记录，而这个数据有可能回滚
- 不可重复读：在一个事务的两次查询结果不一样，可能是两次查询中插入了一个事务更新的原有数据
- 幻读：在一个事务的两次查询中数据笔数不一致，两次查询中有其他事务新插入了数据

#### 隔离等级

- **读未提交：**允许读到未提交的数据，查询不使用锁，可能会产生脏读、幻读、不可重复读
- **读已提交**：只能读取已提交的数据，可避免脏读，如果需要避免不可重复读或者幻读，需要我们SQL查询时便携带加锁的语句
- **可重复读**：(默认)保证一个事物在相同条件下两次查询得到数据结果一致，无法避免幻读
- **可串行化**：将事务串行化，在一个队列中按照顺序执行，是最高级别的隔离等级，可以解决其他异常情况，到那时牺牲了系统的并发性。一般在分布式事务中采用此隔离等级。

#### 锁

**按照粒度**
可以分为行级锁(InnoDb)、表级锁(MyIsam)、页锁(BDB引擎)

行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突概率最低，并发度也最高
表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
页级锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；

**按类别**
共享锁和排他锁

共享锁：又叫读锁。进行数据读取时，对数据加上共享锁。共享锁可以加上多个。
排他锁：又叫写锁。进行数据写入时，对数据加上排他锁。排他锁只可以加一个，和其他的排他锁、共享锁都互斥。

**InnoDb中锁的算法**
Recored lock： 单行记录的锁
Gap loclk：间隙锁，锁定一个范围，不包括记录本身
Next-key lock：record+gap 锁定一个范围，包含记录本身

相关知识

1. innodb对于行的查询使用next-key lock
2. Next-locking key为了解决幻读问题
3. 当查询的索引含有唯一属性时，将next-key降级为record key
4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围中，这样会导致幻读问题
5. 有两种方式显示关闭gap锁；将事务Gili等级设置为可重复读，将参数innodb_locks_unsafe_for_binlog

**什么是死锁，怎么解决**

两个或者多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

1. 不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
2. 在同一个事务中，尽可能做到一次锁定所有需要的资源，减少死锁产生概率
3. 对于非常容易产生死锁的业务部分，可以尝试升级锁定粒度，通过表级锁来减少死锁产生的概率

**乐观锁和悲观锁**

悲观锁：假定会发生冲突，屏蔽一切可能违反数据完整性的操作。查询数据时就把事务锁起来，直到提交事务。使用数据库的锁机制实现。
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改时把事务锁起来，通过version的方式进行锁定。实现方式，使用版本号机制或者CAS来实现。

不同的隔离隔离登记通过锁来实现，有行锁和表锁，行锁简单可分为读锁(共享锁[S锁])和写锁(排他锁[X锁])

![mysql的锁](https://mmbiz.qpic.cn/mmbiz_jpg/E44aHibktsKa23y7eBdg7ZkHNEoIDMgVkHcnHuT3go1n2Dvs3KmPHUUx5sxwHgULpeIZvob8K9Rhdy27XtmSRtA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)



MVCC通过生成数据快照片，并用这个快照来实现不同的隔离登记。

可重复读，同一条sql只会生成一个ReadView，读已提交每次都会生成一个。
通过比对里面的事务版本好来判断该行记录是否可以被查询到。

