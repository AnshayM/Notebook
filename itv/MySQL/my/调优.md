##### 使用explain分析sql语句

**Id：**执行计划包含的信息中id有一组数字，表示一个查询中各个子查询的执行顺序
id相同，顺序由上而下
id不同，id值越大优先级越高
id为null表示一个结果集，不需要使用其他查询，常出现在union等查询语句中

**select_type**： 每个子查询的查询类型
simple 不包含任何子查询或者union等查询
primary 包含子查询、外层查询
subquery 在select或where子句中包含的查询
union 出现在union后的查询语句中
union result 从union中获取结果集

table：查询的表

partitions：表分区

**type**：访问类型，可以看到有没有走索引
all 扫描全表
index 遍历索引
range 索引范围查找
....



**大表数据查询，怎么优化**

1. 优化shema、sql语句+索引
2. 第二加缓存，memcached，redis；
3. 主从复制，读写分离
4. 垂直拆分，根据模块的耦合度。
5. 水平拆分，针对数据量比较大的表。要选择一个合理的shaeding key

**超大分页怎么处理**
例如在分页查询中，order by M limit N,当M为100000，N为10，这里丢弃了大量无用数据，怎么优化

1.使用覆盖索引

2.优化offset，重点在于快速过滤前M条数据，可以利用自增主键有序条件，先查询出M+1的id值。
弊端：id可能不连续

3.延迟关联
在查询出具体的10条数据后，再进行关联查询。如，用子查询包裹。select xxxx from where id in (select id from xxxx where xxx order by xxx limit 100000 limit 10)

#### 慢日志查询

用于记录执行时间超过某个临界值的sql日志，用于快速定位慢查询。
**开启慢查询日志**
配置项：slow_query_log ,可以使用 show variables like 'slow_query_log'查看是否开启
。如果为OFF，可以使用set slow_query_log =on 来开启，它会在datadir下产生一个xxx-slow.log的文件

**设置临界时间**
配置项：long_query_time 查看：show variables like 'long_query_time' ,单位秒。设置：set long_query_time=0.5
实操应该从长时间设置到短时间，将慢的sql优化掉。
查看日志，一旦sql超过了设置的临界时间就会被记录到xxx.log中

**慢查询怎么优化**
1.在测试库上测试其耗时
2.判别原因：是否条件未命中索引/是否load了不需要的数据列/数据量过大

查看是否load了额外的数据后并且抛弃了
分析语句的执行计划，优化对应的索引命中情况。

**主键使用自增id还是uuid**
使用自增id，这样新数据直接往后排列即可。
uuid的大小不确定，会造成非常多的数据插入，数据移动，导致产生狠毒哦的内存碎片，进而造成插入性能的下降。

**字段为什么要定义为 not null**
null值会占用更多的字节，且在程序中造成很多与预期不符的情况

**密码散列怎么存储**
散列密码、盐、用户身份证号等固定长度的字符串，使用char而不是varcahr来存储，可以节省空间提高检索效率。











1. 选择合适的**DBMS**
    阵营区别：SQL和NoSQL，不同的数据库对于事物处理和查询性能略有不同，例如SQLServer，单表存储上亿条数据也没有问题。
    进行事务处理选择InnoDB，非事务处理可以选择MyISAM

NoSql阵营包括：key-value数据库、文档数据库、搜索引擎、列式存储、图形数据库。

1. **优化表设计**

2. 表结构尽量遵守第三范式
    1NF：数据库中的任何属性都是原子性的，不可再分
    2NF：数据表里的非主属性都要和这个数据表的候选键有完全依赖关系
    3NF：在满足2NF的同时，对任何非主属性都不传递依赖与候选键

1. **优化逻辑查询**

换一种写法，是算法层面的优化。  通过改变sql语句的内容让sql执行效率更高
sql的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等
在where子句中尽量避免对字段进行函数运算，他们会让字段的索引失效。

 

1. **优化物理查询**

通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。

1. **使用****Redis****或者****memcached****作为缓存**

   Redis支持持久化，可以让数据存在硬盘中，这样性能消耗比较大。memcached仅仅是内存存储，不支持持久化。

   从支持的数据来说，Redis比memcached要多，它不仅支持key-value类型数据，还支持List、Set、Hash等数据结构

#### 慢查询检查

slow_query_log
默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：
mysql> show variables  like '%slow_query_log%';

用来查看sql执行情况
EXPLAIN select * from t_car_copy

1. **库级优化**

库级优化是在数据库的维度上进行的优化策略，比如控制一个库中的表数量，另外可以采用主从架构优化读写策略。

1. 控制库内数据表数
2. 读写分离，主库master做写操作，从库slave做读操作

 

**垂直切分**：字段数量较多，将经常用的字段划到一个表，其他字段划到另一个表
**水平切分**：同一结构的表，按某一列的值区分到不同表，比如2017年、2018年、2019年的数据分别存三张表，三个表结构相同，数据不同

 

注：分拆在提升性能时也会增加维护和使用成本