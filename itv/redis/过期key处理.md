#### 过期键的删除策略

- **定时删除**：设置键的同时，配置一个定时器timer，让定时器在过期时间来临时立即执行删除操作。

    优点：对内存友好
    缺点：对CPU时间非常不友好
    当服务器创建大量的定时器，服务器处理命令请求的性能会降低。所以Redis目前没有采用。

- **惰性删除**：放任过期键不管，每次从键空间获取键时，检查获得的键是否过期，过期就删除，否则返回。

    优点：对CPU时间非常友好
    确定：对内存非常不友好
    过多的过期键保留会占用内存资源。

- **定期删除**：每隔一段时间就对数据库进行一次检查，删除里面的过期键。
    每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。通过定期删除过期键，也有效减少了过期键带来的内存浪费。

Redis服务器使用的是惰性删除+定期删除策略

###### **惰性删除策略**

由expireIfNeeded函数实现.所有读写数据库的Redis操作在执行之前都会调用expireIfNeeded函数对键进行检查
已过期：删除
未过期：不做处理

###### **定期删除策略**

由activeExpireCycle函数实现.每当Redis服务器周期性操作serverCron函数时，acticeExpireCycle函数就会被调用，会在规定的时间内，分多次遍历服务器中的各个数据库，从数据库中的expires字典汇总随机检查一部分键的过期时间，并删除其中的过期键。

###### **Redis的回收策略（淘汰策略-简单了解）**

关联问题，mysql里有200w数据，redis只保存20w数据，如何保证redis中数据都是热点数据

- Volatile-lru(Least recently used): 从配置了过期时间的数据中，选择最近最少使用的
- volatile-ttl: 从配置了过期时间的数据中，将要过期的
- Volatile-random: 从配置了过期时间的数据中，随机
- Alleys-lru: 内存不足容纳写入新数据时，从所有数据中，挑选最少使用的(最常用的)
- Allkeys-random：所有数据中，随机淘汰
- No-enviction: 禁止驱逐数据，内存不足时写入操作报错。

4.0版本后新增

- Volatile-lfu(least frequently used): 从已设置过期时间的数据集中，最不经常使用的
- Alleys-lfu(least frequently used): 从所有数据中，移除最不经常使用的

###### RDB对过期键的处理

**生成RDB文件**
生成RDB文件，执行svae或者bsave命令创建一个新的rdb文件时，程序会对数据库中的键做检查，已过期的不会创建到新的rdb文件中。

**载入RDB文件**
启动Redis服务器时，如果只开启了rdb持久化，服务器会载入rdb文件

- 如果服务器以主模式运行，载入rdb文件时，程序会对文件保存的键进行检查，未过期的键会保存到数据库中，过期会忽略
- 如果服务器以从服务器，在载入edb文件时，文件中所有键，不论是否过期都会被载入到数据库中。

因为主从服务器在进行数据同步(完成重同步)时，从服务器的数据库会被清空

###### AOF对过期键的处理

**aof文件写入**
服务器开启了AOF，过期键被惰性删除或者定期删除后，程序会向aof文件中追加一条del命令，显式记录该键已被删除

- 从数据库中删除message键
- 追加一条Del message命令到AOF文件，向执行GET message的客户端返回空回复。

**aof文件重写**
执行aof文件重写时，会对数据库的键进行检查，已过期的不会被保存到重写后的aof文件中。

###### **主从服务对过期键的处理**

- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键
- 从服务器在执行客户端发送的读命令时，即使发现该键已过期也不会删除该键，照常返回该键的值
- 从服务器只有在接收到主服务器发送的DEL命令后，才会删除过期键

