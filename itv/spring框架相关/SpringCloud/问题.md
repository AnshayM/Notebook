## CAP无法同时满足

**一致性**Consistency：分布式环境下多个节点的数据是否强一致。
**可用性**Avaliability：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限的时间内返回结果。
**分区容忍性**Patition Tolerance：对网络分区的容忍性。

**BASE理论**

**基本可用**(Basically Available)：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用
**软状态**(Soft State)：指分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性
**最终一致性**(Eventual Consistency)：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态

## 分布式事务、分布式锁

### 分布式事务解决方案

工程领域讨论的是强一致性和最终一致性的解决方案：

1. **两阶段提交**(2PC,Two-phase Commit)方案-强一致性

    通过提交分阶段和记日志的方式，记录下事务提交所处的状态。组件宕机/重启后，可以通过日志恢复事务提交的阶段状态，并在这个状态重试。

    Coordinator重启后，通过日志判断当前所处状态。prepare--有组件诶呦prepare成功，或所有节点prepare成功但是没有下发commit，状态恢复后下发rollback；prepareAll--给所有节点下发commit。数据库节点需要保证commit**幂等**。

    问题：同步阻塞、数据不一致、单点问题
    升级为3PC后，增加超时机制、两阶段之间插入准备阶段。

2. **ebay事件队列方案**

    将需要分布式处理的任务通过消息/日志的方式异步执行，消息/日志可以存到本地文件、数据库、消息队列，再通过业务规则进行失败重试。它要求服务的接口是**幂等**的。

    可能需要一个操作记录表来判定某些操作是否已经完成，以此来实现业务的幂等性。

3. **TCC**（Try-Confirm-Cancel）补偿模式

    服务A-B-C的调用链，在后段失败是，需要对前面的操作进行回滚，保证整个微服务系统的数据的一致性。

    关键要素：

    1. 服务调用链必须被记录下来
    2. 每个服务提供着都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等。
    3. 必须按失败原因执行不同的回滚策略。

4. **缓存数据最终一致性**

    当修改了落库数据后，但是从缓存拿到的还是过时数据，造成了数据不一致的问题。

    1. 缓存设置过期时间。过期后重新获取

    2. 更新数据库后同步清除缓存数据。让下次请求从数据库获取，并同步到缓存。

这几种方式，根据具体的场景来选择。



### 分布式锁的几种实现方式

#### 1.使用redis实现分布式锁

WATCHMULTI\EXEC\DISCARD事务机制实现分布式锁

``` c
MULTI
some redis command
EXEC
```

在multi和exec包裹的redis明亮，保证所有事务内的命令会串行执行，不会在执行过程中被其他客户端打断。
watch命令能监视某个键，当事务执行时，被监视的键被其他客户端修改了值，事务运行失败，返回响应错误。



#### 使用memcached实现分布式锁



#### 使用zookeeper实现分布式锁









#### dubbo和springCloud的区别

Dubbo是soa的产物，关注点在于服务的调用用、流量分发、流量监控和熔断。目标在于服务治理。
SpringCloud诞生于微服务架构时代考虑的是微服务治理的方方面面，另外依托了spring、springBoot的优势。目标在于打造一个生态。

**Dubbo**底层使用Netty这种NIO框架，基于TCP协议，配合以Heesion序列化完成RPC通信，
**SpringCloud**是基于Http协议Rest接口调用远程过程的通信。相对来说Http请求会有更大的报文，占的带宽也会更多。但REST相比RPC更为灵活，服务提供方和调用方的依赖只靠一纸契约，不存在代码级别的强依赖，在快速演变的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。

